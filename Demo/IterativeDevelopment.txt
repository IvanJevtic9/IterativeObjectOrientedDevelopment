
	Summary

Section1:

- In this opening module we have defined the requirements for a sample application
  Then, we have applied the principles of iterative development to implement the requirements

- You can rely on iterative development when implementing an algorithm
  or when implementing the straight-forward code all the same

- The idea behind it is that any development can be split into iterations
  and every iteration broken down into even smaller iterations
  The goal of the game is to reach such small, limited iterations
  that it takes only a line or two of code to implement them

- Every piece of code which is iteratively added to the code base is there to implement one tiny requirement
  As long as that requirement stays intact, the corresponding piece of code will remain correct

- Requirements rarely remain intact, They change over time
  New ones come, old ones change, evolve or disappear
  How will the code built with principles of iterative development in mind survive these changes?
  That remains to be seen, and that is precisely what we will be dealing with in the next module

- The goal of the module to come will be to figure the deficiencies of the current implementation
  to fix the issues and try to implement more customer’s requirements

Section2: 

- The previous module has left us with an implementation which looked like a program that works
  In this module, we have tried to live with that code, and to maintain it
  That included adding more features, fixing bugs and trying to improve performance
  The truth is that this module was suffering all the way through
  The program which fails to obey principles of good object-oriented design is hard to maintain

- It is hard to add new features to it
  I used a lot of copy-paste to add more behavior, which is plain wrong
  It is hard to change the implementation when elements are not decoupled,
  because every single change is modifying several things simultaneously

- Again, due to the lack of separation between elements of the design,
  I was utterly unable to modify the algorithm when I found the performance bottleneck
 All the way through, I was constantly suffering due to the lack of proper abstractions

- Whatever abstractions I could find in the NET Framework and apply to my design,
  all of them turned to be misplaced, and they eventually caused a lot of damage to clarity and extensibility of my code
  So, those are the issues that have been identified this far

- Bad design consists of no decoupling, tangled implementation of the algorithm, and missing abstractions
  That will be the approach known as Emergent Design

- It sits on top of the iterative development, which I was applying constantly throughout this demonstration
  But it adds the designing effort to every iteration, no matter how small or isolated it might be
  One step at the time, a well-thought-out design will emerge

- The application will be able to do whatever it is doing right now
  But it will suddenly become maintainable
